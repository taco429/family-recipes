# Cursor Rules for Family Recipes React TypeScript Project

## Project Context
This is a React TypeScript application using Material-UI, React Router, and modern testing tools.

## General TypeScript Rules

### Type Safety
- Always use explicit types for function parameters and return values
- Prefer `interface` over `type` for object shapes unless using unions/intersections
- Use strict TypeScript settings and avoid `any` - prefer `unknown` when type is unclear
- Use type assertions sparingly and only when you're certain of the type
- Prefer const assertions (`as const`) for immutable data structures

### Code Organization
- Use named exports over default exports for better refactoring support
- Group imports: external libraries, internal modules, relative imports
- Use absolute imports from `src/` when possible
- Keep files focused and under 300 lines when practical

## React-Specific Rules

### Component Structure
- Use functional components with hooks over class components
- Define component props with TypeScript interfaces ending in `Props`
- Use React.FC sparingly - prefer explicit function declarations with typed props
- Keep component files organized: imports, types, component, export

### Hooks and State Management
- Use `useState` with explicit type parameters when type can't be inferred
- Prefer `useCallback` for event handlers passed to child components
- Use `useMemo` for expensive computations, not for object/array creation
- Custom hooks should start with `use` and return objects, not arrays

### Event Handling
- Use proper event types (e.g., `React.ChangeEvent<HTMLInputElement>`)
- Prefer event handler props over inline functions for performance
- Use `useCallback` for event handlers to prevent unnecessary re-renders

## Material-UI (MUI) Best Practices

### Component Usage
- Use MUI's sx prop for styling over makeStyles or styled components when possible
- Leverage MUI's theme system for consistent spacing, colors, and typography
- Use MUI's Grid system for responsive layouts
- Prefer MUI components over custom HTML elements when available

### Theming
- Use theme.palette for colors, theme.spacing for margins/padding
- Utilize theme.breakpoints for responsive design
- Keep custom theme overrides minimal and well-documented

## Testing Guidelines

### Component Testing
- Write tests for user interactions, not implementation details
- Use Testing Library's queries in order of preference: getByRole, getByLabelText, getByText
- Mock external dependencies and API calls
- Test error states and loading states

### E2E Testing (Playwright)
- Focus on critical user journeys
- Use data-testid attributes sparingly, prefer semantic selectors
- Keep tests independent and able to run in any order

## Code Quality Rules

### Performance
- Use React.memo for components that receive stable props
- Avoid creating objects/arrays in render methods
- Use lazy loading for routes and heavy components
- Optimize bundle size by avoiding unnecessary imports

### Error Handling
- Use Error Boundaries for component error handling
- Implement proper loading and error states in components
- Use try-catch blocks for async operations
- Provide meaningful error messages to users

### Accessibility
- Always include proper ARIA labels and roles
- Ensure keyboard navigation works properly
- Use semantic HTML elements when not using MUI components
- Maintain proper heading hierarchy (h1, h2, h3, etc.)

## File Naming and Structure

### Naming Conventions
- Use PascalCase for component files and names
- Use camelCase for functions, variables, and file names (except components)
- Use UPPER_SNAKE_CASE for constants
- Use descriptive names that explain purpose, not implementation

### Project Structure
- Keep components in `/src/components/` with one component per file
- Use `/src/pages/` for route components
- Place shared utilities in `/src/utils/`
- Keep types in component files or `/src/types/` for shared types

## Import/Export Patterns

### Imports
```typescript
// External libraries first
import React, { useState, useCallback } from 'react';
import { Box, Typography, Button } from '@mui/material';
import { useNavigate } from 'react-router-dom';

// Internal modules
import { RecipeService } from '../services/RecipeService';
import { Recipe } from '../types/Recipe';

// Relative imports last
import './ComponentName.css';
```

### Exports
- Use named exports for components, utilities, and types
- Export interfaces and types that might be used by other components
- Avoid default exports except for pages/routes

## Code Examples

### Component Structure
```typescript
interface RecipeCardProps {
  recipe: Recipe;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
}

export const RecipeCard: React.FC<RecipeCardProps> = ({ 
  recipe, 
  onEdit, 
  onDelete 
}) => {
  const [isLoading, setIsLoading] = useState(false);
  
  const handleEdit = useCallback(() => {
    onEdit(recipe.id);
  }, [recipe.id, onEdit]);
  
  return (
    <Box sx={{ p: 2, border: 1, borderColor: 'divider' }}>
      {/* Component content */}
    </Box>
  );
};
```

### Custom Hook
```typescript
interface UseRecipesReturn {
  recipes: Recipe[];
  loading: boolean;
  error: string | null;
  addRecipe: (recipe: Omit<Recipe, 'id'>) => Promise<void>;
}

export const useRecipes = (): UseRecipesReturn => {
  // Hook implementation
};
```

## Additional Notes
- Follow the existing Prettier configuration for formatting
- Use ESLint rules and fix warnings promptly
- Leverage TypeScript's strict mode benefits
- Keep dependencies up to date and remove unused ones
- Document complex business logic with JSDoc comments